---
title: "íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì œë„¤ë¦­ ì‹¬í™”: ê³ ê¸‰ íŒ¨í„´ê³¼ ì‹¤ìš© ì‚¬ë¡€"
description: "íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì œë„¤ë¦­ì˜ ì‹¬í™” ê°œë…ë¶€í„° ì‹¤ì „ í”„ë¡œì íŠ¸ ì ìš©ê¹Œì§€, ì „ë¬¸ê°€ ìˆ˜ì¤€ì˜ íƒ€ì… ì„¤ê³„ë¥¼ ë§ˆìŠ¤í„°í•˜ì„¸ìš”"
pubDate: 2025-01-24
category: "Tools & Frameworks"
tags: ["typescript", "generics", "programming-patterns", "ê³ ê¸‰-íŒ¨í„´", "íƒ€ì…-ì„¤ê³„"]
locale: "ko"
author: "Oiyo íŒ€"
featured: false
---

# íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì œë„¤ë¦­ ì‹¬í™”: ê³ ê¸‰ íŒ¨í„´ê³¼ ì‹¤ìš© ì‚¬ë¡€

íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì œë„¤ë¦­ì€ íƒ€ì… ì•ˆì •ì„±ê³¼ ì½”ë“œ ì¬ì‚¬ìš©ì„±ì„ ë™ì‹œì— ì¡ëŠ” ê°•ë ¥í•œ ë„êµ¬ì…ë‹ˆë‹¤. ì´ ê¸€ì—ì„œëŠ” ê¸°ë³¸ì„ ë„˜ì–´ ì‹¤ì „ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê³ ê¸‰ íŒ¨í„´ë“¤ì„ ë‹¤ë£¹ë‹ˆë‹¤.

## ğŸ¯ ì œë„¤ë¦­ì˜ ë³¸ì§ˆ

ì œë„¤ë¦­ì€ íƒ€ì…ì„ ë³€ìˆ˜ì²˜ëŸ¼ ë‹¤ë£¨ëŠ” ë°©ë²•ì…ë‹ˆë‹¤:

```typescript
// ê¸°ë³¸ ì œë„¤ë¦­
function identity<T>(arg: T): T {
  return arg;
}

// ì—¬ëŸ¬ íƒ€ì… ë§¤ê°œë³€ìˆ˜
function pair<T, U>(first: T, second: U): [T, U] {
  return [first, second];
}
```

## ğŸ—ï¸ ê³ ê¸‰ ì œë„¤ë¦­ íŒ¨í„´

### 1. ì¡°ê±´ë¶€ íƒ€ì…

íƒ€ì…ì„ ì¡°ê±´ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬í•©ë‹ˆë‹¤:

```typescript
// ì¡°ê±´ë¶€ íƒ€ì… ê¸°ë³¸ ë¬¸ë²•
type IsArray<T> = T extends any[] ? true : false;

type Test1 = IsArray<string[]>; // true
type Test2 = IsArray<string>;   // false

// ë” ë³µì¡í•œ ì¡°ê±´ë¶€ íƒ€ì…
type UnpackArray<T> = T extends (infer U)[] ? U : never;
type UnpackedString = UnpackArray<string[]>; // string
```

### 2. ë§¤í•‘ íƒ€ì…

ê°ì²´ì˜ ëª¨ë“  ì†ì„±ì„ ë³€í™˜í•©ë‹ˆë‹¤:

```typescript
type Optional<T> = {
  [K in keyof T]?: T[K];
};

type Person = {
  name: string;
  age: number;
};

type OptionalPerson = Optional<Person>;
// { name?: string; age?: number; }

// ë” ë³µì¡í•œ ë§¤í•‘
type ReadonlyDeep<T> = {
  readonly [K in keyof T]: T[K] extends object ? ReadonlyDeep<T[K]> : T[K];
};
```

### 3. í…œí”Œë¦¿ ë¦¬í„°ëŸ´ íƒ€ì…

ë¬¸ìì—´ì„ íƒ€ì… ë ˆë²¨ì—ì„œ ì¡°ì‘í•©ë‹ˆë‹¤:

```typescript
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

interface User {
  name: string;
  age: number;
  email: string;
}

type UserGetters = Getters<User>;
/*
{
  getName: () => string;
  getAge: () => number;
  getEmail: () => string;
}
*/

// URL íŒŒë¼ë¯¸í„° íƒ€ì… ë§Œë“¤ê¸°
type UrlParams<T extends string> = T extends `${infer Param}=${infer Value}`
  ? { [K in Param]: Value }
  : never;

type Params = UrlParams<"id=123&name=john&active=true">;
// { id: "123"; name: "john"; active: "true" }
```

## ğŸ”§ ì‹¤ì „ ì œë„¤ë¦­ ìœ í‹¸ë¦¬í‹°

### 1. API ì‘ë‹µ íƒ€ì…

```typescript
interface ApiResponse<T = any> {
  data: T;
  message: string;
  status: 'success' | 'error';
  code: number;
}

// ì‚¬ìš© ì˜ˆì‹œ
interface User {
  id: number;
  name: string;
  email: string;
}

async function fetchUser(id: number): Promise<ApiResponse<User>> {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}

// ì—ëŸ¬ ì‘ë‹µë„ íƒ€ì… ì•ˆì •ì„± ìœ ì§€
type ErrorResponse = ApiResponse<never>;
```

### 2. ìƒíƒœ ê´€ë¦¬ ì œë„¤ë¦­

```typescript
interface State<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

type Actions<T> = {
  setLoading: (loading: boolean) => void;
  setData: (data: T) => void;
  setError: (error: string | null) => void;
  reset: () => void;
}

function createState<T>(initial: T | null = null): [State<T>, Actions<T>] {
  let state: State<T> = {
    data: initial,
    loading: false,
    error: null
  };

  const actions: Actions<T> = {
    setLoading: (loading) => { state.loading = loading; },
    setData: (data) => { state.data = data; state.error = null; },
    setError: (error) => { state.error = error; state.data = null; },
    reset: () => { state = { data: initial, loading: false, error: null }; }
  };

  return [state, actions];
}
```

### 3. ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ ì œë„¤ë¦­

```typescript
type EventMap<T extends Record<string, any>> = {
  [K in keyof T]: (payload: T[K]) => void;
};

class EventEmitter<T extends Record<string, any>> {
  private listeners: { [K in keyof T]?: Array<(payload: T[K]) => void> } = {};

  on<K extends keyof T>(event: K, callback: (payload: T[K]) => void) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event]!.push(callback);
  }

  emit<K extends keyof T>(event: K, payload: T[K]) {
    const callbacks = this.listeners[event];
    if (callbacks) {
      callbacks.forEach(callback => callback(payload));
    }
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
interface AppEvents {
  userLoggedIn: { userId: string; timestamp: Date };
  dataUpdated: { type: string; data: any };
  errorOccurred: { message: string; code: number };
}

const emitter = new EventEmitter<AppEvents>();

emitter.on('userLoggedIn', ({ userId, timestamp }) => {
  console.log(`User ${userId} logged in at ${timestamp}`);
});
```

## ğŸ§® ê³ ê¸‰ íƒ€ì… ì¶”ë¡ 

### 1. infer í‚¤ì›Œë“œ ì‹¬í™”

```typescript
// ë°°ì—´ ìš”ì†Œ íƒ€ì… ì¶”ë¡ 
type ArrayElement<T> = T extends (infer U)[] ? U : never;

// í•¨ìˆ˜ ë°˜í™˜ íƒ€ì… ì¶”ë¡ 
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

// í•¨ìˆ˜ íŒŒë¼ë¯¸í„° íƒ€ì… ì¶”ë¡ 
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

// Promise íƒ€ì… ì¶”ë¡ 
type UnpackPromise<T> = T extends Promise<infer U> ? U : T;

// ì¤‘ì²©ëœ íƒ€ì… ì¶”ë¡ 
type DeepUnpackPromise<T> = T extends Promise<infer U>
  ? U extends Promise<any>
    ? DeepUnpackPromise<U>
    : U
  : T;

// ì‚¬ìš© ì˜ˆì‹œ
type UsersPromise = Promise<User[]>;
type Users = UnpackPromise<UsersPromise>; // User[]
type NestedPromise = Promise<Promise<string>>;
type NestedString = DeepUnpackPromise<NestedPromise>; // string
```

### 2. ì¬ê·€ì  íƒ€ì…

```typescript
// ê¹Šì´ ìˆëŠ” ì„ íƒì  íƒ€ì…
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// ê°ì²´ì˜ ëª¨ë“  ê²½ë¡œë¥¼ ë¬¸ìì—´ë¡œ
type Path<T> = T extends object
  ? {
      [K in keyof T]: K extends string
        ? T[K] extends object
          ? `${K}.${Path<T[K]>}`
          : K
        : never;
    }[keyof T]
  : never;

interface NestedObject {
  user: {
    profile: {
      name: string;
      email: string;
    };
    settings: {
      theme: 'light' | 'dark';
      notifications: boolean;
    };
  };
}

type ObjectPaths = Path<NestedObject>;
/*
"user.profile.name" |
"user.profile.email" | 
"user.settings.theme" |
"user.settings.notifications"
*/
```

## ğŸ¯ ì‹¤ì „ ì‚¬ë¡€: ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ë¹Œë”

```typescript
interface QueryCondition {
  equals?: any;
  in?: any[];
  contains?: string;
  greaterThan?: number;
  lessThan?: number;
}

type Query<T> = {
  [K in keyof T]?: QueryCondition;
};

type SortOrder = 'asc' | 'desc';
type Sort<T> = {
  field: keyof T;
  order: SortOrder;
};

interface QueryBuilder<T> {
  where(conditions: Query<T>): QueryBuilder<T>;
  sortBy(sort: Sort<T>): QueryBuilder<T>;
  limit(count: number): QueryBuilder<T>;
  offset(count: number): QueryBuilder<T>;
  execute(): Promise<T[]>;
  count(): Promise<number>;
}

class RealQueryBuilder<T> implements QueryBuilder<T> {
  private query: {
    where: Query<T> = {};
    sort?: Sort<T>;
    limit?: number;
    offset?: number;
  } = {};

  where(conditions: Query<T>): this {
    this.query.where = { ...this.query.where, ...conditions };
    return this;
  }

  sortBy(sort: Sort<T>): this {
    this.query.sort = sort;
    return this;
  }

  limit(count: number): this {
    this.query.limit = count;
    return this;
  }

  offset(count: number): this {
    this.query.offset = count;
    return this;
  }

  async execute(): Promise<T[]> {
    // ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ì‹¤í–‰ ë¡œì§
    console.log('Executing query:', this.query);
    return [];
  }

  async count(): Promise<number> {
    console.log('Counting with query:', this.query);
    return 0;
  }
}

// ì‚¬ìš© ì˜ˆì‹œ
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
  isActive: boolean;
  createdAt: Date;
}

const userQuery = new RealQueryBuilder<User>()
  .where({
    isActive: { equals: true },
    age: { greaterThan: 18 },
    name: { contains: 'John' }
  })
  .sortBy({ field: 'createdAt', order: 'desc' })
  .limit(10)
  .offset(0);

const users = await userQuery.execute();
```

## ğŸš€ ì„±ëŠ¥ ìµœì í™” íŒ

### 1. íƒ€ì… ë„ˆë¹„ ìµœì†Œí™”

```typescript
// ë‚˜ìœ ì˜ˆì‹œ: ë„ˆë¬´ ë„“ì€ íƒ€ì…
function processData<T extends any>(data: T): void {
  // anyì™€ ë‹¤ë¦„ ì—†ìŒ
}

// ì¢‹ì€ ì˜ˆì‹œ: êµ¬ì²´ì ì¸ ì œì•½
function processData<T extends { id: string }>(data: T): void {
  // ìµœì†Œí•œ id ì†ì„±ì´ ìˆë‹¤ëŠ” ê²ƒì„ ë³´ì¥
}
```

### 2. ì¡°ê±´ë¶€ íƒ€ì… ìµœì í™”

```typescript
// ë³µì¡í•œ ì¡°ê±´ë¶€ íƒ€ì…ì€ ë¶„ë¦¬í•´ì„œ ì‚¬ìš©
type ComplexCondition<T> = T extends string
  ? T extends `${infer Prefix}_${infer Suffix}`
    ? { prefix: Prefix; suffix: Suffix }
    : never
  : never;

// ë” ì½ê¸° ì‰¬ê²Œ ë¶„ë¦¬
type HasUnderscore<T> = T extends `${string}_${string}` ? T : never;
type SplitByUnderscore<T> = T extends `${infer Prefix}_${infer Suffix}`
  ? { prefix: Prefix; suffix: Suffix }
  : never;

type ParseString<T> = HasUnderscore<T> extends never
  ? never
  : SplitByUnderscore<T>;
```

## ğŸ“š ëª¨ë²” ì‚¬ë¡€

1. **í•­ìƒ êµ¬ì²´ì ì¸ ì œì•½ ì¡°ê±´ ì‚¬ìš©**: `any` ëŒ€ì‹  êµ¬ì²´ì ì¸ íƒ€ì…
2. **ë³µì¡í•œ íƒ€ì…ì€ ì‘ê²Œ ë¶„ë¦¬**: ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„± í–¥ìƒ
3. **íƒ€ì… ë„ˆë¹„ ìµœì†Œí™”**: ë¶ˆí•„ìš”í•œ ì¼ë°˜í™” í”¼í•˜ê¸°
4. **ë¬¸ì„œí™” ì£¼ì„ ì¶”ê°€**: ë³µì¡í•œ ì œë„¤ë¦­ì€ ì„¤ëª… í•„ìš”
5. **í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„±**: íƒ€ì…ì´ ì˜ë„ëŒ€ë¡œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸

## ğŸ‰ ê²°ë¡ 

íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì œë„¤ë¦­ì€ ë‹¨ìˆœí•œ ë¬¸ë²•ì´ ì•„ë‹ˆë¼, íƒ€ì… ìˆ˜ì¤€ì—ì„œ ì¶”ìƒí™”ì™€ ì¬ì‚¬ìš©ì„±ì„ êµ¬í˜„í•˜ëŠ” ê°•ë ¥í•œ íŒ¨ëŸ¬ë‹¤ì„ì…ë‹ˆë‹¤. ê³ ê¸‰ íŒ¨í„´ë“¤ì„ ë§ˆìŠ¤í„°í•˜ë©´ ë” ì•ˆì •ì ì´ê³  ìœ ì§€ë³´ìˆ˜í•˜ê¸° ì‰¬ìš´ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì‹¤ì „ í”„ë¡œì íŠ¸ì—ì„œ ì´ íŒ¨í„´ë“¤ì„ ì ìš©í•´ë³´ë©° íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì˜ ì§„ì •í•œ í˜ì„ ê²½í—˜í•´ë³´ì„¸ìš”! ğŸ’ª

## ğŸ”— ì¶”ê°€ í•™ìŠµ ìë£Œ

- [TypeScript Handbook - Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
- [Advanced TypeScript Types](https://type-level-typescript.com/)
- [Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)