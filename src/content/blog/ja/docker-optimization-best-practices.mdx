---
title: "Dockerコンテナ最適化：本番環境向けベストプラクティス"
description: "本番環境でのDockerコンテナ最適化テクニックとベストプラクティスを完全ガイド"
pubDate: 2025-01-25
category: "DevOps & Cloud"
tags: ["docker", "devops", "optimization", "本番環境", "パフォーマンス"]
locale: "ja"
author: "Oiyo チーム"
featured: false
---

# Dockerコンテナ最適化：本番環境向けベストプラクティス

Dockerコンテナの最適化は、本番環境でのパフォーマンス、セキュリティ、コスト効率に直接影響します。このガイドでは、実践的な最適化テクニックを網羅的に解説します。

## 🏗️ 基本的な最適化原則

### マルチステージビルド

```dockerfile
# Build stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

# Production stage
FROM node:18-alpine AS production
WORKDIR /app

# 非rootユーザーの作成
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# ビルド成果物のみコピー
COPY --from=builder --chown=nextjs:nodejs /app/dist ./dist
COPY --from=builder --chown=nextjs:nodejs /app/node_modules ./node_modules

USER nextjs

EXPOSE 3000
CMD ["node", "dist/server.js"]
```

### 最小化ベースイメージ

```dockerfile
# 良くない例
FROM ubuntu:20.04
RUN apt-get update && apt-get install -y nodejs npm

# 良い例
FROM node:18-alpine
# Alpine Linuxは~5MB
# Ubuntuは~100MB
```

## 🚀 ビルド最適化

### キャッシュ戦略

```dockerfile
# Docker layerキャッシュを活用
FROM node:18-alpine
WORKDIR /app

# 依存関係は頻繁に変わらないので先にコピー
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# ソースコードは最後にコピー
COPY . .
RUN npm run build
```

### .dockerignoreの活用

```plaintext
# .dockerignore
node_modules
npm-debug.log
.git
.gitignore
README.md
.env
.nyc_output
coverage
.nyc_output
.coverage
```

## 🔐 セキュリティ最適化

### 非rootユーザーの使用

```dockerfile
FROM node:18-alpine

# セキュリティグループとユーザー作成
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

WORKDIR /app
COPY --chown=nextjs:nodejs . .
USER nextjs

EXPOSE 3000
CMD ["npm", "start"]
```

### 最小権限原則

```yaml
# docker-compose.yml
version: '3.8'
services:
  app:
    build: .
    user: "1001:1001"  # 非rootユーザー
    read_only: true        # ファイルシステム読み取り専用
    tmpfs:
      - /tmp           # 一時ファイル用
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
    environment:
      - NODE_ENV=production
    ports:
      - "3000:3000"
```

## 📊 パフォーマンス最適化

### メモリ制限

```yaml
version: '3.8'
services:
  app:
    build: .
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
```

### ヘルスチェック

```dockerfile
FROM node:18-alpine
WORKDIR /app

# ヘルスチェックスクリプト
COPY --chown=node:node healthcheck.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/healthcheck.sh

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD /usr/local/bin/healthcheck.sh

EXPOSE 3000
CMD ["node", "server.js"]
```

```bash
#!/bin/sh
# healthcheck.sh
curl -f http://localhost:3000/health || exit 1
```

## 🔧 本番環境設定

### 環境変数管理

```yaml
# docker-compose.prod.yml
version: '3.8'
services:
  app:
    build: .
    environment:
      - NODE_ENV=production
      - PORT=3000
      - DATABASE_URL=${DATABASE_URL}
      - JWT_SECRET=${JWT_SECRET}
    env_file:
      - .env.production
    secrets:
      - db_password
```

```bash
# .env.production
NODE_ENV=production
PORT=3000
```

### ログ管理

```yaml
version: '3.8'
services:
  app:
    build: .
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    labels:
      - "logging=promtail"
```

## 🎯 コンテナサイズ最適化

### レイヤー分析

```bash
# Dockerイメージレイヤー分析
docker history my-app:latest

# 詳細な分析
dive my-app:latest
```

### 最適化テクニック

```dockerfile
FROM node:18-alpine AS builder
WORKDIR /app

# 依存関係クリーンインストール
COPY package*.json ./
RUN npm ci --only=production && \
    npm cache clean --force && \
    rm -rf /tmp/*

# 本番用イメージ
FROM node:18-alpine AS production
RUN apk add --no-cache dumb-init

WORKDIR /app

# 必要なファイルのみコピー
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules

# 不要なファイル削除
RUN rm -rf /var/cache/apk/* && \
    rm -rf /tmp/*

USER node
EXPOSE 3000

ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "dist/server.js"]
```

## 🔄 CI/CD統合

### GitHub Actions

```yaml
# .github/workflows/docker.yml
name: Build and Push Docker Image

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm test

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            myorg/myapp:latest
            myorg/myapp:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
```

## 📈 モニタリングと監視

### Prometheus統合

```dockerfile
FROM node:18-alpine
WORKDIR /app

# Prometheus metrics endpoint
COPY --chown=node:node .
RUN npm install prom-client

# ヘルスチェックとメトリクス
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js

EXPOSE 3000 9090
USER node
CMD ["node", "server.js"]
```

```javascript
// healthcheck.js
const http = require('http');

const options = {
  hostname: 'localhost',
  port: 3000,
  path: '/health',
  method: 'GET',
  timeout: 2000
};

const req = http.request(options, (res) => {
  process.exit(res.statusCode === 200 ? 0 : 1);
});

req.on('error', () => {
  process.exit(1);
});

req.on('timeout', () => {
  req.destroy();
  process.exit(1);
});

req.end();
```

## 🎯 ベストプラクティスまとめ

### DO
- ✅ マルチステージビルドを使用
- ✅ 最小化ベースイメージを選択
- ✅ 非rootユーザーを実行
- ✅ 適切なキャッシュ戦略
- ✅ ヘルスチェック実装
- ✅ リソース制限設定

### DON'T
- ❌ rootユーザーで実行
- ❌ 開発用依存関係を本番に含める
- ❌ 機密情報をイメージに埋め込む
- ❌ 不要なパッケージをインストール
- ❌ 固定的なパスワードを使用

## 📊 パフォーマンスベンチマーク

### ビルド時間比較

| 最適化前 | 最適化後 | 改善率 |
|---------|---------|--------|
| 2m 30s | 45s | 70%高速化 |
| 1.2GB | 180MB | 85%削減 |
| 850MB | 320MB | 62%削減 |

### 実行パフォーマンス

```bash
# コンテナパフォーマンス測定
docker stats --no-stream my-app

# メモリ使用量
docker exec my-app free -h

# CPU使用率
docker exec my-app top
```

## 🔗 参考リソース

- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)
- [Alpine Linux](https://alpinelinux.org/)
- [Docker Security Best Practices](https://docs.docker.com/engine/security/best-practices/)

最適化されたコンテナで、高速で安全な本番環境を構築しましょう! 🚀